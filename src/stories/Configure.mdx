# edu-components


> The solution to make your code survive the test of time!

## React Hooks and Their Use in Atomic Design

### **Atoms**
- **`useState`**:
  - Often used to manage state for individual atom components, such as toggling a button or managing the value of an input field.

### **Molecules**
- **`useState`**:
  - Still frequently used here, especially to handle state for interactive molecules (e.g., forms, dropdowns).
- **`useEffect`**:
  - Sometimes used to handle side effects that occur within a molecule, such as fetching suggestions for an autocomplete component.

### **Organisms**
- **`useState`**:
  - Managing the internal state of an organism, such as a complex form or a modal dialog.
- **`useEffect`**:
  - More commonly used here to handle data fetching, subscriptions, or manual DOM manipulation needed for the organism to function.

### **Templates**
- **`useContext`**:
  - Useful for sharing state or configurations across various organisms within a template.
- **`useEffect`**:
  - Often used to manage data fetching that affects multiple organisms displayed in the template.
- **`useReducer`**:
  - May be used to manage more complex state transitions involving multiple organisms within a template.

### **Pages**
- **`useContext`**:
  - For managing global state that affects the entire page, such as theme or user authentication data.
- **`useEffect`**:
  - Heavily used for handling global side effects, like fetching data necessary for the entire page.
- **`useReducer`**:
  - Suitable for managing the overall state of the page, especially if there are complex state changes that involve multiple templates or organisms.


## Understanding Atomic Design: Atom Level Components

### The Goal of Atom Components

Atom components are the foundational elements of atomic design. They are the smallest, indivisible building blocks of your UI, analogous to HTML tags like `<button>`, `<input>`, and `<label>`. The primary goals of atom components in an atomic design system are:

1. **Reusability**: Atoms are designed to be reused across your entire application. Their simplicity makes them easy to plug into various parts of your UI without requiring modifications.

2. **Consistency**: By defining atomic components once and using them throughout the application, you maintain a consistent design language, which enhances the user experience.

3. **Simplicity**: These components are minimalistic, usually focusing on a single responsibility. For instance, a Button component is responsible only for rendering a button with provided properties.

4. **Ease of Composition**: Since atoms are small and focused, they can easily be combined to create more complex UI elements. They serve as the basic units that make up molecules and organisms in atomic design.

5. **Maintainability**: Managing small, isolated components makes it easier to update, test, and maintain your code. Changes in the atom-level components can seamlessly propagate throughout the app.

### Example: A Button Atom

A typical example of an atom component is a Button. It encapsulates everything required to render a button:

```jsx
// Button.jsx
import React from 'react';

// Simple Button component
const Button = ({ label, onClick }) => {
  return (
    <button onClick={onClick}>
      {label}
    </button>
  );
};

export default Button;
```

## Understanding Atomic Design: Molecule Level Components

### The Goal of Molecule Components

Molecule components in atomic design represent the next level above atoms. They consist of multiple atom components combined to form a more complex yet reusable UI unit. The main goals of molecule components are:

1. **Composability**: Molecules are designed by combining multiple atoms, making them useful building blocks for more complex UI components.

2. **Reusability**: Like atoms, molecules are meant to be reused across the application. They offer a higher level of abstraction by encapsulating multiple related components into a single, self-contained unit.

3. **Encapsulation**: Molecule components encapsulate their internal structure and behavior, simplifying their integration into larger structures and ensuring consistent behavior across the app.

4. **Focused Functionality**: Molecules provide specific functionality. For instance, a search bar might consist of an input field and a button, working together to accomplish a singular task.

5. **Maintainability**: With atoms abstracted into molecules, maintaining code becomes easier. Updating a molecule's internal structure or behavior will update its instances across the app.

### Example: A SearchBar Molecule

A typical example of a molecule component is a SearchBar. It consists of an input (atom) and a button (atom) working together:

```jsx
// SearchBar.jsx
import React, { useState } from 'react';
import Button from './Button';

const SearchBar = ({ onSearch }) => {
  const [query, setQuery] = useState('');

  const handleSearch = () => {
    onSearch(query);
  };

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      <Button label="Search" onClick={handleSearch} />
    </div>
  );
};

export default SearchBar;
```

## Understanding Atomic Design: Organism Level Components

### The Goal of Organism Components

Organism components represent a higher level of abstraction in atomic design. They consist of groups of molecules (and possibly atoms) working together to form distinct sections of an application’s UI. The goals of organism components are:

1. **Complex Composability**: Organisms encapsulate more complex combinations of components, offering more advanced structures and functionality.

2. **Reusability**: They can be reused across the application where specific sections of UI are needed, such as headers, footers, or card lists.

3. **Encapsulation**: Organisms group and manage the internal interactions of their composed molecules and atoms, ensuring that the section works as a cohesive unit.

4. **Focused Functionality**: Organisms handle larger pieces of functionality, providing a clear division between distinct sections of the application’s UI.

5. **Maintainability**: Their encapsulation makes it easy to update, manage, and test significant UI sections independently.

### Example: A Header Organism

A typical example of an organism component is a Header, which could include navigation, branding, and a search bar:

```jsx
// Header.jsx
import React from 'react';
import SearchBar from './SearchBar';

const Header = () => {
  const handleSearch = (query) => {
    console.log('Search for:', query);
  };

  return (
    <header>
      <div className="logo">MyApp</div>
      <nav>
        <ul>
          <li><a href="/home">Home</a></li>
          <li><a href="/about">About</a></li>
          <li><a href="/contact">Contact</a></li>
        </ul>
      </nav>
      <SearchBar onSearch={handleSearch} />
    </header>
  );
};

export default Header;
```

## Understanding Atomic Design: Template Level Components

### The Goal of Template Components

Template components in atomic design represent structured layouts that arrange organisms, molecules, and atoms into predefined layouts. They do not contain actual content but instead define the structure of a page or section. The goals of template components are:

1. **Scalable Structure**: Templates define a consistent structure for pages, allowing content and components to fit seamlessly into their predefined slots.

2. **Reusability**: They are reusable layouts that can be adapted across multiple pages by populating them with different content or components.

3. **Consistency**: By defining consistent layouts, templates ensure that pages have a cohesive structure, enhancing the user experience.

4. **Flexibility**: Templates act as blueprints, making it easy to switch or rearrange components without affecting the overall layout.

### Using Templates with Storybook

Storybook can be used to visualize templates to understand how different components will appear in their slots:

1. **Organism-Level Storybook**: Some projects may choose to stop visualizing components at the organism level in Storybook, focusing on smaller-scale UI components.

2. **Separate Storybook for Templates**: Others may prefer to separate templates into a different Storybook setup, ensuring that complex layouts don't overwhelm the component library.

3. **Combined Storybook**: A single Storybook instance can be used to include both organisms and templates, enabling a comprehensive view of the design system.

### Example: Dashboard Template

A typical example of a template is a Dashboard layout:

```jsx
// DashboardTemplate.jsx
import React from 'react';
import Header from './Header';
import Sidebar from './Sidebar';

const DashboardTemplate = ({ children }) => {
  return (
    <div className="dashboard-layout">
      <Header />
      <Sidebar />
      <main>{children}</main>
    </div>
  );
};

export default DashboardTemplate;
```

## Understanding Atomic Design: Page Level Components

### The Goal of Page Components

Page components in atomic design represent complete, high-fidelity representations of entire web pages. They assemble templates with actual content and serve as the final stage in atomic design. The goals of page components are:

1. **Realistic Context**: Pages provide the highest level of fidelity, showcasing how components, molecules, organisms, and templates come together to form a complete page.

2. **Content Specificity**: Pages contain real content, enabling developers to see how various design elements work with actual data and assets.

3. **Testing and Validation**: They allow for end-to-end testing of how different components interact and ensure the overall UI and UX meet the application's requirements.

### Using Pages with Storybook

Using pages in Storybook provides a holistic view of the application:

1. **Stop at Template Level**: Some projects may prefer to stop visualizing components at the template level to avoid replicating the application in Storybook.

2. **Separate Storybook for Pages**: Others may maintain a separate Storybook instance for pages to focus on the specific design and content of full pages.

3. **Combined Storybook**: Some projects might prefer to use a single Storybook instance, covering everything from atoms to pages, for a unified design system.

### Example: Home Page Component

Here's a simplified example of a page component that combines a template with specific content:

```jsx
// HomePage.jsx
import React from 'react';
import DashboardTemplate from './DashboardTemplate';

const HomePage = () => {
  return (
    <DashboardTemplate>
      <h1>Welcome to the Dashboard</h1>
      <p>This is the home page of the application.</p>
    </DashboardTemplate>
  );
};

export default HomePage;
```
